import React, { useState, useRef } from 'react';

const App = () => {
const [selectedImage, setSelectedImage] = useState(null);
const [plantInfo, setPlantInfo] = useState(null);
const [sampleImages, setSampleImages] = useState([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState('');
const fileInputRef = useRef(null);

// Function to convert image file to base64
const fileToBase64 = (file) => {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.readAsDataURL(file);
reader.onload = () => resolve(reader.result.split(',')[1]); // Get base64 string without data:image/png;base64,
reader.onerror = error => reject(error);
});
};

// Handle image selection
const handleImageChange = async (event) => {
const file = event.target.files[0];
if (file) {
if (!file.type.startsWith('image/')) {
setError('Please upload an image file (e.g., JPG, PNG).');
return;
}
setSelectedImage(URL.createObjectURL(file));
setPlantInfo(null);
setSampleImages([]);
setError('');
setLoading(true);

try {
const base64Image = await fileToBase64(file);
await identifyAndDescribePlant(base64Image);
} catch (err) {
console.error("Error processing image:", err);
setError('Failed to process image. Please try again.');
setLoading(false);
}
}
};

// Simulate "Take Picture" by triggering file input
const handleTakePicture = () => {
fileInputRef.current.click();
};

// Function to handle image loading errors for sample images
const handleSampleImageError = (e) => {
e.target.onerror = null; // Prevent infinite loop if placeholder also fails
e.target.src = `https://placehold.co/128x128/cccccc/000000?text=Image+Error`;
};

// Main function to identify and describe the plant using AI
const identifyAndDescribePlant = async (base64Image) => {
setLoading(true);
setError('');
setPlantInfo(null);
setSampleImages([]);

try {
// Step 1: Identify the plant name using gemini-2.0-flash (image understanding)
let chatHistoryIdentify = [];
chatHistoryIdentify.push({
role: "user",
parts: [
{ text: "Identify the plant in this image. Provide only the common name of the plant. If it's not a plant or cannot be identified, respond with 'Unknown Plant'." },
{ inlineData: { mimeType: "image/png", data: base64Image } }
]
});

const identifyPayload = { contents: chatHistoryIdentify };
const apiKey = ""; // API key is provided by the environment
const identifyApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

const identifyResponse = await fetch(identifyApiUrl, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify(identifyPayload)
});
const identifyResult = await identifyResponse.json();

if (!identifyResult.candidates || identifyResult.candidates.length === 0 || !identifyResult.candidates[0].content || !identifyResult.candidates[0].content.parts || identifyResult.candidates[0].content.parts.length === 0) {
throw new Error("Could not identify the plant. Please try a clearer image.");
}

const plantName = identifyResult.candidates[0].content.parts[0].text.trim();

if (plantName === "Unknown Plant" || plantName.toLowerCase().includes("cannot identify")) {
setError("Could not identify the plant. Please try a clearer image or a different plant.");
setLoading(false);
return;
}

// Step 2: Generate description, health aspects, and maintenance tips using gemini-2.0-flash (text generation)
let chatHistoryDescribe = [];
chatHistoryDescribe.push({
role: "user",
parts: [{ text: `Provide the common name, a brief description (maximum 100 words, including where it typically grows), general health aspects/uses of the plant (5 points), and 5 maintenance tips for ${plantName}. Format the response as a JSON object with the following keys: 'name' (string), 'description' (string), 'health_aspects' (array of 5 strings), 'maintenance_tips' (array of 5 strings).` }]
});

const describePayload = {
contents: chatHistoryDescribe,
generationConfig: {
responseMimeType: "application/json",
responseSchema: {
type: "OBJECT",
properties: {
"name": { "type": "STRING" },
"description": { "type": "STRING" },
"health_aspects": { "type": "ARRAY", "items": { "type": "STRING" }, "maxItems": 5, "minItems": 5 },
"maintenance_tips": { "type": "ARRAY", "items": { "type": "STRING" }, "maxItems": 5, "minItems": 5 }
},
"propertyOrdering": ["name", "description", "health_aspects", "maintenance_tips"]
}
}
};

const describeResponse = await fetch(identifyApiUrl, { // Reusing identifyApiUrl as it's for gemini-2.0-flash
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify(describePayload)
});
const describeResult = await describeResponse.json();

if (!describeResult.candidates || describeResult.candidates.length === 0 || !describeResult.candidates[0].content || !describeResult.candidates[0].content.parts || describeResult.candidates[0].content.parts.length === 0) {
throw new Error("Could not generate plant details.");
}

const parsedPlantInfo = JSON.parse(describeResult.candidates[0].content.parts[0].text);
setPlantInfo(parsedPlantInfo);

// Step 3: Generate sample images using imagen-3.0-generate-002
const imagePayload = {
instances: { prompt: `5 realistic images of ${plantName} in different natural settings or close-ups.` },
parameters: { "sampleCount": 5 }
};
const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

const imageResponse = await fetch(imageApiUrl, {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify(imagePayload)
});
const imageResult = await imageResponse.json();

if (imageResult.predictions && imageResult.predictions.length > 0) {
const generatedImages = imageResult.predictions.map(pred => `data:image/png;base64,${pred.bytesBase64Encoded}`);
setSampleImages(generatedImages);
} else {
console.warn("Could not generate sample images.");
}

} catch (err) {
console.error("API call error:", err);
setError(`An error occurred: ${err.message}. Please try again.`);
} finally {
setLoading(false);
}
};

return (
<div className="min-h-screen bg-gradient-to-br from-green-100 to-blue-100 p-4 font-inter text-gray-800 flex flex-col items-center">
  <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-2xl mt-8">
    <h1 className="text-3xl font-bold text-center text-green-700 mb-6">Plant Identifier</h1>

    <div className="flex flex-col items-center space-y-4 mb-6">
      <input
        type="file"
        accept="image/*"
        onChange={handleImageChange}
        ref={fileInputRef}
        className="hidden"
      />
      <button
        onClick={() => fileInputRef.current.click()}
      className="w-full md:w-auto px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
      >
      Upload Plant Image
      </button>
      <button
        onClick={handleTakePicture}
        className="w-full md:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
      >
        Take Picture (Upload from device)
      </button>
    </div>

    {selectedImage && (
    <div className="mb-6 text-center">
      <h2 className="text-xl font-semibold text-gray-700 mb-2">Selected Image:</h2>
      <img src={selectedImage} alt="Selected Plant" className="max-w-full h-auto rounded-lg shadow-md mx-auto" />
    </div>
    )}

    {loading && (
    <div className="text-center text-green-600 text-lg font-medium">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-green-600 mx-auto mb-2"></div>
      Identifying plant and fetching details...
    </div>
    )}

    {error && (
    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-6">
      <strong className="font-bold">Error:</strong>
      <span className="block sm:inline"> {error}</span>
    </div>
    )}

    {plantInfo && (
    <div className="space-y-6">
      <div className="bg-green-50 p-4 rounded-lg shadow-sm">
        <h2 className="text-2xl font-bold text-green-800 mb-2">{plantInfo.name}</h2>
        <p className="text-gray-700 text-base leading-relaxed">{plantInfo.description}</p>
      </div>

      <div className="bg-blue-50 p-4 rounded-lg shadow-sm">
        <h3 className="text-xl font-semibold text-blue-800 mb-2">Health Aspects/Uses:</h3>
        <ul className="list-disc list-inside text-gray-700 space-y-1">
          {plantInfo.health_aspects && plantInfo.health_aspects.map((aspect, index) => (
          <li key={index}>{aspect}</li>
          ))}
        </ul>
      </div>

      <div className="bg-yellow-50 p-4 rounded-lg shadow-sm">
        <h3 className="text-xl font-semibold text-yellow-800 mb-2">Maintenance Tips:</h3>
        <ul className="list-disc list-inside text-gray-700 space-y-1">
          {plantInfo.maintenance_tips && plantInfo.maintenance_tips.map((tip, index) => (
          <li key={index}>{tip}</li>
          ))}
        </ul>
      </div>

      {sampleImages.length > 0 && (
      <div className="bg-purple-50 p-4 rounded-lg shadow-sm">
        <h3 className="text-xl font-semibold text-purple-800 mb-4">Sample Images:</h3>
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
          {sampleImages.map((imgSrc, index) => (
          <img
            key={index}
            src={imgSrc}
            alt={`Sample of ${plantInfo.name} ${index + 1}`}
            className="w-full h-32 object-cover rounded-lg shadow-md"
            onError={handleSampleImageError} // Using the new function here
          />
          ))}
        </div>
      </div>
      )}
    </div>
    )}
  </div>
</div>
);
};

export default App;
